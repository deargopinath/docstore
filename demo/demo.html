<html>
<body>
<h1>Groningen MySQL Document Store Demonstration</h1>
Open a terminal and connect to the machine running the database. Then work through this document from top to bottom. Read the content
and type in the commands that are written in red font.
<h2>MySQL Shell Basic Usage</h2>
The purpose of this section is to demonstrate how to invoke MySQL shell, to toggle between the various language interfaces and 
otherwise make yourself aware of the built-in commands and objects.<p>
To invoke MySQL shell, open a terminal and enter:<pre>
unix$ <font color=red>mysqlsh</font>
</pre>
Ask for help by entering:<pre>
 MySQL  JS > <font color=red>\help</font>
</pre>
The help will detail both commands and objects. Use commands to toggle between the various language interfaces (JavaScript -> Python ->
SQL -> JavaScript) :<pre>
 MySQL  JS > <font color=red>\py</font>
 MySQL  PY > <font color=red>\sql</font>
 MySQL  SQL > <font color=red>\js</font>
 MySQL  JS >
</pre>
Currently we have only started the MySQL Shell client; we have not connected to a server. To connect to the server we can use either
\connect or the short form as follows:<pre> 
 MySQL  JS > <font color=red>\c root@localhost</font>
Creating a session to 'root@localhost'
Please provide the password for 'root@localhost': <font color=red>*********</font>
Save password for 'root@localhost'? [Y]es/[N]o/Ne[v]er (default No):
Fetching schema names for autocompletion... Press ^C to stop.
Your MySQL connection id is 17 (X protocol)
Server version: 8.0.17-commercial MySQL Enterprise Server - Commercial
No default schema selected; type \use <schema> to set one.
 MySQL  localhost:33060+ ssl  JS >
</pre>
Note how the prompt has changed. Even though the database is local we connect over TCP/IP using port 33060 (the default for the XDevAPI)
and TLS/SSL.<br>
We can ask for help using a short form command. Enter the following and compare the objects we can now use with those we could use 
prior to connecting<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>\h</font>
</pre>
You should see that a new object called <b>session</b> is available. This makes sense because you have just started a session by 
connecting to a database server. You can ask for help about the session object in order to learn what it can do:<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>session.help()</font>
</pre>
One of the items in the help details that we can get a list of schema names. To do this enter:<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>session.getSchemas()</font>
</pre>
Now toggle to the SQL interface and run the analogous SQL command show databases<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>\sql</font>
 MySQL  localhost:33060+ ssl  SQL > <font color=red>show databases;</font>
</pre>
You should see that the schemas and the databases are very similar. Again, this makes sense because in MySQL terms a schema is a database. 
It also provides a clue as to how MySQL handles collections. (Assuming you followed the instructions in the Github README then you 
should have imported a JSON collection called nycfood). Toggle back to the JavaScript interface:<pre>
 MySQL  localhost:33060+ ssl  SQL > <font color=red>\js</font>
</pre>
<h2>Using Document Store</h2>
In the example that follows we will create a schema called <it>ancestors</it>. This schema will be a repository for a collection of
(JSON) documents that will describe our fore-fathers...
<h3>Creating a Schema</h3>
We create a schema in a session, so look at the help session can provide.<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>session.help()</font>
</pre>
You should be able to see that session has a method called createSchema - this looks promising - we can drill down for more help
as follows:<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>session.help('createSchema')</font>
</pre>
It should now be clear that this method will create a schema and will return an object that we can use as a handle to this schema, so:<pre>
 MySQL  localhost:33060+ ssl  JS >  <font color=red>var mySchema = session.createSchema('ancestors')</font>
</pre>
So let's see what a schema object can do:<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>mySchema.help()</font>
 MySQL  localhost:33060+ ssl  JS > <font color=red>mySchema.help('createCollection')</font>
</pre>
So we can now create a collection of (JSON) documents in the schema we created.
<h3>Creating a Collection, Populating and Query It</h3>
Create a collection and then ask for help from the resulting collection:<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>var col = mySchema.createCollection('flintstones')</font>
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.help()</font>
</pre>
The help details many CRUD operations. Let's use the add() method (which is the 'create' in CRUD):<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.add({"name": "Fred", "type": "Early human"})</font>
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.add({"name": "Barney", "type": "Early human"})</font>
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.add({"name": "Dino", "type": "Dinosaur"})</font>
</pre>
Note that we are adding JSON documents, this may be more obvious if we display the first document in a more familiar 'pretty' JSON form:<pre>
    {
	    "name": "Fred",
	    "type": "Early Human"
    }
</pre>
Of course when we code we would typically create objects and add them rather than use literals:<pre>
    // Some code
    var myObj = {"name": "Betty", "type": "Early Human"}
    // some more code, and then
    col.add(myObj)
</pre>
Returning to our example, it is important to remember that just as humans evolve so do applications, here we have to add an extra key 
value pair. Compare this to adding a column in traditional SQL:<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.add({"name": "Wilma", "type": "Developed human", "brain": true</font>
</pre>
Let's see what we have inserted by querying the collection - this is the Read operation in CRUD<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.find()</font>
 {
    "_id": "00005d75ef300000000000000001",
    "name": "Fred",
    "type": "Early human"
}
{
    "_id": "00005d75ef300000000000000002",
    "name": "Barney",
    "type": "Early human"
}
{
    "_id": "00005d75ef300000000000000003",
    "name": "Dino",
    "type": "Dinosaur"
}
{
    "_id": "00005d75ef300000000000000004",
    "name": "Wilma",
    "type": "Developed human",
    "brain": true
}
4 documents in set (0.0006 sec)
 MySQL  localhost:33060+ ssl  JS >
</pre>
The previous command brings back all of the documents in the collection. Some points to note:
<ol>
<li>Each document has an extra key-value pair inserted, _id: "28-char-string-of-numbers".</li> 
<li>The last document has a further extra key-value pair, "brain": true</li>
</ol>
The _id will be discussed in more detail later in the demo. It should be noted that we can chose the fields we wish to display by
simply chaining the fields() method to the find() method:<pre> 
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.find().fields(["name","type","brain"])</font>
{
    "name": "Fred",
    "type": "Early human",
    "brain": null
}
{
    "name": "Barney",
    "type": "Early human",
    "brain": null
}
{
    "name": "Dino",
    "type": "Dinosaur",
    "brain": null
}
{
    "name": "Wilma",
    "type": "Developed human",
    "brain": true
}
4 documents in set (0.0007 sec)

</pre>
We can also sort on one or more fields (keys). The default is to sort ascending (i.e. A before Z, 1 before 2). Descending sorts can be
done by adding the word 'desc' after the name of the field.<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.find().fields(["name","type"]).sort(["type"])</font>
{
    "name": "Wilma",
    "type": "Developed human"
}
{
    "name": "Dino",
    "type": "Dinosaur"
}
{
    "name": "Fred",
    "type": "Early human"
}
{
    "name": "Barney",
    "type": "Early human"
}
4 documents in set (0.0005 sec)
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.find().fields(["name","type"]).sort(["type","name"])</font>
{
    "name": "Wilma",
    "type": "Developed human"
}
{
    "name": "Dino",
    "type": "Dinosaur"
}
{
    "name": "Barney",
    "type": "Early human"
}
{
    "name": "Fred",
    "type": "Early human"
}
4 documents in set (0.0006 sec)
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.find().fields(["name","type"]).sort(["type desc","name"])</font>
{
    "name": "Barney",
    "type": "Early human"
}
{
    "name": "Fred",
    "type": "Early human"
}
{
    "name": "Dino",
    "type": "Dinosaur"
}
{
    "name": "Wilma",
    "type": "Developed human"
}
4 documents in set (0.0006 sec) 
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.find().fields(["name","type"]).sort(["type desc","name desc"])</font>
{
    "name": "Fred",
    "type": "Early human"
}
{
    "name": "Barney",
    "type": "Early human"
}
{
    "name": "Dino",
    "type": "Dinosaur"
}
{
    "name": "Wilma",
    "type": "Developed human"
}
4 documents in set (0.0005 sec) 
 MySQL  localhost:33060+ ssl  JS > 
</pre>
We can also filter results in the find method:<pre> 
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.find('type="Early human"').fields(["name","type"]).sort(["name"])</font>
{
    "name": "Barney",
    "type": "Early human"
}
{
    "name": "Fred",
    "type": "Early human"
}
2 documents in set (0.0011 sec) 
 MySQL  localhost:33060+ ssl  JS > 
</pre>
<h3>Transactions</h3>
Document Store transactions are exactly similar to SQL transactions: a transaction either works in its entirety or it is rolled-back
to a known state. A further point to note is that until a transaction is committed all other sessions have a view of the before state
of the data. For the purposes of this demonstration, open another terminal, connect to the schema and obtain a collection object<pre>
<b>Terminal 2</b>
unix$ <font color=red>mysqlsh</font> 
 MySQL  JS > <font color=red>\c root@localhost</font>
Creating a session to 'root@localhost'
Please provide the password for 'root@localhost': <font color=red>*********</font>
...
 MySQL  localhost:33060+ ssl  JS > <font color=red>var col = session.getSchema('ancestors').getCollection('flintstones')</font>
 MySQL  localhost:33060+ ssl  JS >
</pre>
In the original terminal, Terminal 1, start the transaction and <i>evolve</i> Fred Flintstone into a "Developed Human" with a "Brain":<pre>
<b>Terminal 1</b>
 MySQL  localhost:33060+ ssl  JS >  <font color=red>session.startTransaction()</font>
 MySQL  localhost:33060+ ssl  JS >  <font color=red>col.find('name = "Fred"')</font>
{
    "_id": "00005d75ef300000000000000001",
    "name": "Fred",
    "type": "Early human"
}
1 document in set (0.0005 sec) 
 MySQL  localhost:33060+ ssl  JS > <font color=red>col.modify('name = "Fred"').set("type","Developed human")</font>
Query OK, 1 item affected (0.0007 sec)
Rows matched: 1  Changed: 1  Warnings: 0
 MySQL  localhost:33060+ ssl  JS >  <font color=red>col.modify('name = "Fred"').set("brain",true)</font>
Query OK, 1 item affected (0.0006 sec)
Rows matched: 1  Changed: 1  Warnings: 0
 MySQL  localhost:33060+ ssl  JS >  <font color=red>col.find('name = "Fred"')</font>)
{
    "_id": "00005d75ef300000000000000001",
    "name": "Fred",
    "type": "Developed human",
    "brain": true
}
1 document in set (0.0005 sec)
 MySQL  localhost:33060+ ssl  JS >
</pre>
We can see that in Terminal 1 session the change has been made but is not yet committed. In the second terminal, look at the state of the
same document: Fred should still be an "Early Human" and not a "Developed Human" with a "Brain"<pre>
<b>Terminal 2</b>
 MySQL  localhost:33060+ ssl  JS >  <font color=red>col.find('name = "Fred"')</font>
{
    "_id": "00005d75ef300000000000000001",
    "name": "Fred",
    "type": "Early human"
}
1 document in set (0.0005 sec) 
 MySQL  localhost:33060+ ssl  JS >
</pre>
Returning to the first terminal we could commit the change. However, for the purposes of this demonstration we will rollback and then
check to make sure "Fred" has reverted to being an "Early Human"<pre>
<b>Terminal 1</b>
 MySQL  localhost:33060+ ssl  JS >  <font color=red>session.rollback()</font>
 MySQL  localhost:33060+ ssl  JS >  <font color=red>col.find('name = "Fred"')</font>
{
    "_id": "00005d75ef300000000000000001",
    "name": "Fred",
    "type": "Early human"
}
1 document in set (0.0005 sec) 
 MySQL  localhost:33060+ ssl  JS >
</pre>
The second terminal can now be dismissed.
<h3>The SQL Interface</h3>
In the remaining terminal toggle to the SQL interface, then list the databases and select the ancestors schema<pre>
 MySQL  localhost:33060+ ssl  JS > <font color=red>\sql</font>
 MySQL  localhost:33060+ ssl  JS > <font color=red>show databases;</font>
 MySQL  localhost:33060+ ssl  JS > <font color=red>use ancestors;</font>
Default schema set to `ancestors`.
Fetching table and column names from `ancestors` for auto-completion... Press ^C to stop.
 MySQL  localhost:33060+ ssl  ancestors  SQL >

</pre>
Now show the schema's tables - there should only be one, flintstones, then describe it:<pre>
 MySQL  localhost:33060+ ssl  ancestors  SQL > <font color=red>show tables;</font>
+---------------------+
| Tables_in_ancestors |
+---------------------+
| flintstones         |
+---------------------+
1 row in set (0.0012 sec)
 MySQL  localhost:33060+ ssl  ancestors  SQL > <font color=red>desc flintstones;</font>
+-------+---------------+------+-----+---------+------------------+
| Field | Type          | Null | Key | Default | Extra            |
+-------+---------------+------+-----+---------+------------------+
| doc   | json          | YES  |     | NULL    |                  |
| _id   | varbinary(32) | NO   | PRI | NULL    | STORED GENERATED |
+-------+---------------+------+-----+---------+------------------+
2 rows in set (0.0013 sec)
 MySQL  localhost:33060+ ssl  ancestors  SQL >
</pre>
We can see that our schema, ancestors, is a database after all, with a table called, flintstones. The table has two columns, _id and 
doc. The doc column is of a json type and is the column in which our documents are stored. We can see this by running the following
query:<pre>
 MySQL  localhost:33060+ ssl  ancestors  SQL > <font color=red>select * from flintstones\G</font>
*************************** 1. row ***************************
doc: {"_id": "00005d75ef300000000000000001", "name": "Fred", "type": "Developed human", "brain": true}
_id: 00005d75ef300000000000000001
*************************** 2. row ***************************
doc: {"_id": "00005d75ef300000000000000002", "name": "Barney", "type": "Early human"}
_id: 00005d75ef300000000000000002
*************************** 3. row ***************************
doc: {"_id": "00005d75ef300000000000000003", "name": "Dino", "type": "Dinosaur"}
_id: 00005d75ef300000000000000003
*************************** 4. row ***************************
doc: {"_id": "00005d75ef300000000000000004", "name": "Wilma", "type": "Developed human", "brain": true}
_id: 00005d75ef300000000000000004
4 rows in set (0.0005 sec)
 MySQL  localhost:33060+ ssl  ancestors  SQL >
</pre>
Note that the _id column is a primary key. This ensures each entry in the table is unique which in turn allows for group replication 
(necessary if a database is to be clustered). Note also that the _id field is replicated into the doc column (and hence the JSON 
document).<p>

One of the most powerful aspects of Document Store is that it is possible to query JSON documents through the SQL interface:<pre>
 MySQL  localhost:33060+ ssl  ancestors  SQL > <font color=red>select doc->'$.name', doc->'$.type' from flintstones;</font>
+---------------+-------------------+
| doc->'$.name' | doc->'$.type'     |
+---------------+-------------------+
| "Fred"        | "Developed human" |
| "Barney"      | "Early human"     |
| "Dino"        | "Dinosaur"        |
| "Wilma"       | "Developed human" |
+---------------+-------------------+
4 rows in set (0.0005 sec)  
 MySQL  localhost:33060+ ssl  ancestors  SQL >
</pre>  
The query takes exactly the same form as any other SQL query:<pre>
    select column1, column2 from table;
</pre>
However, there is a subtlety: the only column being selected from is doc and we are effectively drilling into that column to 
retrieve the value for a specified key. For example, <tt>doc->'$.name'</tt>, means extract the value of the key 'name' from the doc 
column. Indeed, the <tt>-></tt> operator has been introduced as a shorthand version of the JSON_EXTRACT function. Consider:<pre>
 MySQL  localhost:33060+ ssl  ancestors  SQL > <font color=red>select JSON_EXTRACT(doc,'$.name'), JSON_EXTRACT(doc,'$.type') from flintstones;</font>
+----------------------------+----------------------------+
| JSON_EXTRACT(doc,'$.name') | JSON_EXTRACT(doc,'$.type') |
+----------------------------+----------------------------+
| "Fred"                     | "Developed human"          |
| "Barney"                   | "Early human"              |
| "Dino"                     | "Dinosaur"                 |
| "Wilma"                    | "Developed human"          |
+----------------------------+----------------------------+
4 rows in set (0.0005 sec)
 MySQL  localhost:33060+ ssl  ancestors  SQL >
</pre>
As we can see the queries are completely analogous.<br>
A further issue with the output is the JSON quoting that surrounds both the keys and the values. To remove these we can use <tt>->></tt>
which is effectively the same as a JSON_UNQUOTE function wrapping a JSON_EXTRACT function. Consider the following two analogous 
queries:<pre>

 MySQL  localhost:33060+ ssl  ancestors  SQL > <font color=red>select doc->>'$.name', doc->>'$.type' from flintstones;</font>
+----------------+-----------------+
| doc->>'$.name' | doc->>'$.type'  |
+----------------+-----------------+
| Fred           | Developed human |
| Barney         | Early human     |
| Dino           | Dinosaur        |
| Wilma          | Developed human |
+----------------+-----------------+
4 rows in set (0.0005 sec)
 MySQL  localhost:33060+ ssl  ancestors  SQL > <font color=red>select JSON_UNQUOTE(JSON_EXTRACT(doc,'$.name')), JSON_UNQUOTE(JSON_EXTRACT(doc,'$.type')) from flintstones;</font>
+------------------------------------------+------------------------------------------+
| JSON_UNQUOTE(JSON_EXTRACT(doc,'$.name')) | JSON_UNQUOTE(JSON_EXTRACT(doc,'$.type')) |
+------------------------------------------+------------------------------------------+
| Fred                                     | Developed human                          |
| Barney                                   | Early human                              |
| Dino                                     | Dinosaur                                 |
| Wilma                                    | Developed human                          |
+------------------------------------------+------------------------------------------+
4 rows in set (0.0005 sec)
 MySQL  localhost:33060+ ssl  ancestors  SQL >
</pre>
Clearly using the short forms, <tt>->  ->></tt>, is preferable to using the functions. We can also tidy up the column headings in the
traditional SQL manner:<pre> 
 MySQL  localhost:33060+ ssl  ancestors  SQL > <font color=red>select doc->>'$.name' as 'Name', doc->>'$.type' as 'Type' from flintstones;</font>
+--------+-----------------+
| Name   | Type            |
+--------+-----------------+
| Fred   | Developed human |
| Barney | Early human     |
| Dino   | Dinosaur        |
| Wilma  | Developed human |
+--------+-----------------+
4 rows in set (0.0004 sec)
 MySQL  localhost:33060+ ssl  ancestors  SQL >
</pre>
<h3>Indexing Collections for Performance</h3>
As collections grow queries will take longer to execute. However, just as with a normal RDBMS we can use indexes to counteract this effect.
In order to show this effect we are going to need a larger dataset than the ancestors' flintstones collection. Therefore, change to the
nycfood schema and use its outlets collection (this should be loaded as part of the install - see the github readme).<pre>
 MySQL  localhost:33060+ ssl  ancestors  SQL > <font color=red>\js</font>
 MySQL  localhost:33060+ ssl  ancestors  JS > <font color=red>\use nycfood</font>
Default schema `nycfood` accessible through db.
 MySQL  localhost:33060+ ssl  ancestors  JS > <font color=red>col = db.getCollection('outlets')</font>
 MySQL  localhost:33060+ ssl  nycfood  JS >
</pre>
Note how the command <tt>\use</tt> has been used as a short cut for <tt>var myvar = session.getSchema('nycfood')</tt>, and that it assigns
the return value (the request schema) to a variable called <tt>db</tt>. We are also re-assigning the collection variable, <tt>col</tt>
we used with the ancestors collection.<br>
The outlets collection has more than 3500 documents. Take a look at a document by querying the collection and returning its first document:<pre>
 MySQL  localhost:33060+ ssl  nycfood  JS > <font color=red>col.find().limit(1)</font>
{
    "_id": "00005d73b30f0000000000000001",
    "name": "Morris Park Bake Shop",
    "grades": [
        {
            "date": {
                "$date": 1393804800000
            },
            "grade": "A",
            "score": 2
        },
        {
            "date": {
                "$date": 1378857600000
            },
            "grade": "A",
            "score": 6
        },
        {
            "date": {
                "$date": 1358985600000
            },
            "grade": "A",
            "score": 10
        },
        {
            "date": {
                "$date": 1322006400000
            },
            "grade": "A",
            "score": 9
        },
        {
            "date": {
                "$date": 1299715200000
            },
            "grade": "B",
            "score": 14
        }
    ],
    "address": {
        "coord": [
            -73.856077,
            40.848447
        ],
        "street": "Morris Park Ave",
        "zipcode": "10462",
        "building": "1007"
    },
    "borough": "Bronx",
    <font color=blue><b>"cuisine": "Bakery",</b></font>
    "restaurant_id": "30075445"
}
1 document in set (0.0006 sec)
 MySQL  localhost:33060+ ssl  nycfood  JS >
</pre>
Each outlet has an associated <font color=blue>cuisine</font> type, Bakery, Indian, French, Chinese, and so on. The set of distinct 
cuisines in the collection can be found using this chain - note the aggregation method, groupBy:<pre>
 MySQL  localhost:33060+ ssl  nycfood  JS > <font color=red>col.find().fields('cuisine').groupBy('cuisine').sort('cuisine')</font> 
{
    "cuisine": "Afghan"
}
{
    "cuisine": "African"
}
...
{
    "cuisine": "Vietnamese/Cambodian/Malaysia"
}
70 documents in set (0.0061 sec)
</pre>
So with 70 cuisine types and more than 3500 outlets we should see benefit from indexing on cuisine when searching on a particular
cuisine type. Let's test the theory by searching for outlets that provide Egyptian cuisine. We start by investigating the time taken
when indexes are not used. We will use both the JavaScript and SQL interfaces - the queries are analogous and so the times taken to 
perform them should be similar (variances may exist due to formatting, etc):<pre>
 MySQL  localhost:33060+ ssl  nycfood  JS > <font color=red>col.find('cuisine = "Egyptian"').fields('name')</font>
{
    "name": "Kabab Cafe"
}
{
    "name": "Mr Falafael Restaurant"
}
2 documents in set <b><font color=blue>(0.0036 sec)</font></b>
 MySQL  localhost:33060+ ssl  nycfood  JS > <font color=red>\sql</font>
 MySQL  localhost:33060+ ssl  nycfood  SQL > <font color=red>select doc->'$.name' from outlets where doc->'$.cuisine' = 'Egyptian';</font>
+--------------------------+
| doc->'$.name'            |
+--------------------------+
| "Kabab Cafe"             |
| "Mr Falafael Restaurant" |
+--------------------------+
2 rows in set <b><font color=blue>(0.0035 sec)</font></b>
</pre>
In the case shown we can see that both queries return a results set in approximately 3.5 milli-seconds. Given we are currently in 
the SQL interface we should take the time to <i>explain</i> the optimizer's execution plan for this query:<pre>

 MySQL  localhost:33060+ ssl  nycfood  SQL > <font color=red>explain select doc->'$.name' from outlets where doc->'$.cuisine' = 'Egyptian'\G</font>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        <font color=blue><b>table: outlets</b></font>
   partitions: NULL
         type: ALL
<font color=blue><b>possible_keys: NULL</b></font>
          <font color=blue><b>key: NULL</b></font>
      key_len: NULL
          ref: NULL
         <font color=blue><b>rows: 3621</b></font>
     filtered: 100
        Extra: Using where
1 row in set, 1 warning (0.0006 sec)
Note (code 1003): /* select#1 */ select json_extract(`nycfood`.`outlets`.`doc`,'$.name') AS `doc->'$.name'` from `nycfood`.`outlets` where (json_extract(`nycfood`.`outlets`.`doc`,'$.cuisine') = 'Egyptian')
 MySQL  localhost:33060+ ssl  nycfood  SQL >
</pre>
From the explain output we can see that for the collection, outlets, there are no possible indexes (keys) that the optimizer can use, 
and that we will need to consider all of the rows. In other words a full table scan is required to execute the query.<br> 
Now let's index on cuisine (using JavaScript):<pre>
 MySQL  localhost:33060+ ssl  nycfood  SQL > <font color=red>\js</font>
 MySQL  localhost:33060+ ssl  nycfood  JS > <font color=red>col.createIndex('idx_outlets_cuisine',{fields: [{"field": "$.cuisine", "type": "TEXT(8)"}]})</font> 
Query OK, 0 rows affected (0.0528 sec)
 MySQL  localhost:33060+ ssl  nycfood  JS >
</pre>
The syntax may look daunting at first, but it is quite simple. All we are asking is to create an index called 'idx_outlets_cuisine'. We
then specify the fields in the collection's document that we will use. Note that indexes can be formed from multiple fields just as
they can be formed from multiple columns with traditional SQL tables. To allow for this the syntax describes a JSON object which has
a key called 'fields'. Its value is an array which allows the specification of one or more fields. We are only indexing on one field
and so we only have one object in the array, {"field": "$.cuisine", "type": "TEXT(8)"}. The field being used is identified by the 
key, cuisine, and it is of type TEXT but we are constraining the build of the index to up to the first eight characters.<br>
Let's see what happens when we rerun the queries<pre>
 MySQL  localhost:33060+ ssl  nycfood  JS > <font color=red>col.find('cuisine = "Egyptian"').fields('name')</font>
{
    "name": "Kabab Cafe"
}
{
    "name": "Mr Falafael Restaurant"
}
2 documents in set <font color=blue>(0.0007 sec)</font></b>
 MySQL  localhost:33060+ ssl  nycfood  JS > <font color=red>\sql</font>
 MySQL  localhost:33060+ ssl  nycfood  SQL > <font color=red>select doc->'$.name' from outlets where doc->'$.cuisine' = 'Egyptian';</font>
+--------------------------+
| doc->'$.name'            |
+--------------------------+
| "Kabab Cafe"             |
| "Mr Falafael Restaurant" |
+--------------------------+
2 rows in set <font color=blue>(0.0006 sec)</font></b>
</pre>
So we can see that we have improved performance by more than a factor of five (i.e. 0.0007 versus 0.0036 seconds). So it would seem 
we are using the index. Check by explaining the query:<pre>
 MySQL  localhost:33060+ ssl  nycfood  SQL > <font color=red>explain select doc->'$.name' from outlets where doc->'$.cuisine' = 'Egyptian'\G</font>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        <font color=blue><b>table: outlets</b></font>
   partitions: NULL
         type: ref
<font color=blue><b>possible_keys: idx_outlets_cuisine</b></font>
          <font color=blue><b>key: idx_outlets_cuisine</b></font>
      key_len: 35
          ref: const
         <font color=blue><b>rows: 2</b></font>
     filtered: 100
        Extra: Using where
1 row in set, 1 warning (0.0007 sec)
Note (code 1003): /* select#1 */ select json_extract(`nycfood`.`outlets`.`doc`,'$.name') AS `doc->'$.name'` from `nycfood`.`outlets` where (json_extract(`nycfood`.`outlets`.`doc`,'$.cuisine') = 'Egyptian')
 MySQL  localhost:33060+ ssl  nycfood  SQL >
</pre>
The explain confirms what we already know: indexing is working. Some points to note:
<ol>
<li>The times you see will depend on your setup, but it is expected that you will get a similar differential.</li>
<li>The dataset being used is still quite small. It is likely that with a larger dataset we would see even greater differentials.</li>
<li>Both unique and non-unique indexes can be created.</li>
</ol>
 
<h3>Joining Collections to Tables and Collections to Collections</h3>
Joining collections with other collections and tables allows us to extract "added-value" from our data. It also allows us to create
that ad-hoc report management want in a matter of minutes; with MySQL Document Store we don't have to write an app to obtain it!<p>
In this demo we will create a schema that looks like the diagram below:<p>
<img src="./nosql.png" align="left", height="400", width="640">
<p style="clear:left">
We will then be able to answer questions like:<br>
what skills did the Flintstones have?<br>
what similarities do a modern family (the Simpsons) have with an ancient family (the Flintstones)?<p>

To set this demo up we would typically have to do a lot of typing. However, the MySQL shell allows both interactive scripting and 
the use of scripts. As such, a "quick and dirty" script has been produced, createJoinDB.js, that will create and populate the schema, 
its collections and tables. It is recommended that you take time to look at this script: it's not pretty but it is functional! The script
is  written in JavaScript but could easily have been written in Python. Hopefully you will understand the potential benefit this can 
bring to both developers and admins. Developers can perform mock up potential solutions without modifying their code. Admins can 
group regular tasks into scripts and use them at defined intervals (e.g. a regular clean down of SQL tables or collections). So let's 
use this script. Start by quitting out of the MySQL Shell client:<pre>
 MySQL  localhost:33060+ ssl  nycfood  SQL > <font color=red>\q</font>
unix$ 
<pre>
Now run the script (make sure you are in the directory where the script is) <pre>
unix$ <font color=red>mysqlsh --uri root@localhost --js -f createJoinDB.js</font>
Please provide the password for 'root@localhost': <font color=red>*********</font>
Save password for 'root@localhost'? [Y]es/[N]o/Ne[v]er (default No):

 THE JOINDB SCHEMA
 =================

 SIMPSON COLLECTION
[
    {
        "_id": "5101",
        "geneBias": "Early human",
        "name": "Homer"
    },
    {
        "_id": "5102",
        "geneBias": "Developed human",
        "name": "Marge"
    },
    {
        "_id": "5103",
        "geneBias": "Early human",
        "name": "Bart"
    },
    {
        "_id": "5104",
        "geneBias": "Developed human",
        "name": "Lisa"
    },
    {
        "_id": "5105",
        "geneBias": "No discernable bias, probably human",
        "name": "Maggie"
    },
    {
        "_id": "5106",
        "geneBias": "Dinosaur",
        "name": "Santa's little helper"
    }
]

 FLINTSTONE COLLECTION
[
    {
        "_id": "1000",
        "name": "Fred",
        "type": "Early human"
    },
    {
        "_id": "1001",
        "name": "Barney",
        "type": "Early human"
    },
    {
        "_id": "1002",
        "name": "Dino",
        "type": "Dinosaur"
    },
    {
        "_id": "1003",
        "brain": true,
        "name": "Wilma",
        "type": "Developed human"
    }
]

  SKILLS TABLE
 id     skill
 1      Fire starting
 2      Beer drinking
 3      Poetry
 4      Car driving (foot mobile)
 5      Gas production
 6      Rock bashing

  SKILLS MATRIX TABLE
 person_id      skill_id
 1000           1
 1000           2
 1000           4
 1000           5
 1000           6
 1001           1
 1001           2
 1001           5
 1001           6
 1002           5
 1003           1
 1003           3
 1003           4
unix$
</pre>
Now log back into MySQL Shell, connect to the database, toggle to the SQL interface and then 'use' the schema that we just created 
(called joindb)<pre>
unix$ <font color=red>mysqlsh</font>
 MySQL  JS > <font color=red>\c root@localhost</font>
Please provide the password for 'root@localhost': <font color=red>*********</font>
...
 MySQL  localhost:33060+ ssl  JS > <font color=red>\sql</font>
 MySQL  localhost:33060+ ssl  SQL > <font color=red>use joindb;</font>
Default schema set to `joindb`.
Fetching table and column names from `joindb` for auto-completion... Press ^C to stop.
 MySQL  localhost:33060+ ssl  joindb  SQL >
</pre>
Now we can join the flintstones table with the skills table (via skills_matrix) to discover what skills our ancestors had:<pre>
 MySQL  localhost:33060+ ssl  joindb  SQL > <font color=red>select f.doc->>'$.name' as 'Name', f.doc->>'$.type' as 'Type', s.skill as 'Skill' 
                                            from skills_matrix m
                                            inner join flintstones f on m.person_id = f._id
                                            inner join skills s on m.skill_id = s.id;</font>
+--------+-----------------+---------------------------+
| Name   | Type            | Skill                     |
+--------+-----------------+---------------------------+
| Fred   | Early human     | Fire starting             |
| Fred   | Early human     | Beer drinking             |
| Fred   | Early human     | Car driving (foot mobile) |
| Fred   | Early human     | Gas production            |
| Fred   | Early human     | Rock bashing              |
| Barney | Early human     | Fire starting             |
| Barney | Early human     | Beer drinking             |
| Barney | Early human     | Gas production            |
| Barney | Early human     | Rock bashing              |
| Dino   | Dinosaur        | Gas production            |
| Wilma  | Developed human | Fire starting             |
| Wilma  | Developed human | Poetry                    |
| Wilma  | Developed human | Car driving (foot mobile) |
+--------+-----------------+---------------------------+
13 rows in set (0.0009 sec)
 MySQL  localhost:33060+ ssl  joindb  SQL >
</pre>
By being able to join a collection with tables we can see that at the bottom of the evolutionary scale Dino is only capable of producing 
gas, Fred and Barney are not much better but have discovered beer drinking and rock bashing, whereas Wilma has evolved further and is 
interested in the arts (poetry).<p>
Now let's add some where clauses to extract further, more refined value:<pre>
 MySQL  localhost:33060+ ssl  joindb  SQL > <font color=red>select f.doc->>'$.name' as 'Name', f.doc->>'$.type' as 'Type', s.skill as 'Skill' 
                                            from skills_matrix m
                                            inner join flintstones f on m.person_id = f._id
                                            inner join skills s on m.skill_id = s.id
		                                    where f.doc->>'$.type' like 'Dev%';</font>
+-------+-----------------+---------------------------+
| Name  | Type            | Skill                     |
+-------+-----------------+---------------------------+
| Wilma | Developed human | Fire starting             |
| Wilma | Developed human | Poetry                    |
| Wilma | Developed human | Car driving (foot mobile) |
+-------+-----------------+---------------------------+
3 rows in set (0.0006 sec)
 MySQL  localhost:33060+ ssl  joindb  SQL > <font color=red>select f.doc->>'$.name' as 'Name', f.doc->>'$.type' as 'Type', s.skill as 'Skill' 
                                            from skills_matrix m
                                            inner join flintstones f on m.person_id = f._id
                                            inner join skills s on m.skill_id = s.id
                                            where s.skill like 'Gas%';</font>
+--------+-------------+----------------+
| Name   | Type        | Skill          |
+--------+-------------+----------------+
| Fred   | Early human | Gas production |
| Barney | Early human | Gas production |
| Dino   | Dinosaur    | Gas production |
+--------+-------------+----------------+
3 rows in set (0.0006 sec)
 MySQL  localhost:33060+ ssl  joindb  SQL >
</pre>
To complete the demonstration join a Collection to a Collection. In this example we will find out what traits the members of the
Simpson family have inherited from the Flintstones:<pre>
 MySQL  localhost:33060+ ssl  joindb  SQL > <font color=red>select f.doc->>'$.name' as 'Flintstone', 
                                            s.doc->>'$.name' as 'Simpson', f.doc->>'$.type' as 'Gene Makeup' 
                                            from flintstones f  
                                            inner join simpsons s on s.doc->>'$.geneBias' = f.doc->>'$.type' 
                                            order by f.doc->>'$.type' desc, f.doc->>'$.name';</font>
+------------+-----------------------+-----------------+
| Flintstone | Simpson               | Gene Makeup     |
+------------+-----------------------+-----------------+
| Barney     | Homer                 | Early human     |
| Barney     | Bart                  | Early human     |
| Fred       | Homer                 | Early human     |
| Fred       | Bart                  | Early human     |
| Dino       | Santa's little helper | Dinosaur        |
| Wilma      | Lisa                  | Developed human |
| Wilma      | Marge                 | Developed human |
+------------+-----------------------+-----------------+
7 rows in set (0.0008 sec)
 MySQL  localhost:33060+ ssl  joindb  SQL >
 </pre>
We can therefore deduce that Bart and Homer have inherited the bulk of their gene makeup from early humans and have somehow
missed out on the genes from developed humans. This is not the case for Lisa and Marge. The Simpson's dog, "Santa's little helper"
inherits from a dinosaur. That's probably all you need to know about evolution...
<h2>Summary</h2>
Hopefully the above demonstration has given you a glimpse of the power of Document Store and has inspired you to use it. Please note there is an awful lot more to learn. The tutorial that compliments this
demo will extend your learning, but the best way of learning is by practising, for which you will need nore documentation:<br>
Website: <a href="https://www.mysql.com/products/enterprise/document_store.html">MySQL Document Store</a><br>
XDevAPI <a href="https://dev.mysql.com/doc/x-devapi-userguide/en/">User Guide</a>. This covers JavaScript (includes MySQL Shell), Python, Java, Node.js, C++ and C# languages; for PHP click <a href="https://www.php.net/manual/en/book.mysql-xdevapi.php">here</a><br>
For an alternative view of human evolution: <a href="https://www.amazon.co.uk/Evolution-Human-Dr-Alice-Roberts/dp/1465474013">Evolution: The Human Story, 2nd Edition</a> by Dr Alice Roberts
</body>
</html>
